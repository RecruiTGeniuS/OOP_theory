# Память
---
## Оглавление
1. А зачем это?
2. Как устроена память в C++
3. Способы организации памяти в C++
4. Переменные и массивы в стеке
5. Выравнивание
6. 
7. Ссылки
---
### **А зачем это?**
--- 
По поводу представления памяти, стека, куча, хранения переменных, указателей, работы ссылок и других аспектов памяти вряд ли будут задавать вопросы на экзамене, но понимание того как и что тут работает будет очень полезно, как и в работе, так и в изучении ООП, к примеру для работы с конструкторами копирования. Ну и к тому же Разумовский очень сильно любит пихать куда надо и не надо указатели, а Новиков ссылки, понимание их механизмов упростит работу с ними.
### **Как устроена память в C++?**
---
Ну что же, не будем брать всё устройство компа, но затронем некоторые основы. Память, которая используется при выполнении программ - оперативка. Она выступает в качетсве буфера между накопителем и процессором, то есть данные сперва считываются с жёсткого диска в ОЗУ, а потом обрабатываются ЦП. То есть схема такая:   
1. Мы пишем код, то есть набор команд  в определённом файле, далее этот файл с набором команд сохраняется на Жёстком диске.
2. Мы запускаем выполнение программы, некоторые данные с программы (типа переменных, или классов) считываются в ОЗУ. Код программы переводится в машинный и передаётся процессору.
3. Процессор начинает выполнять операции, заданные программой, все промежуточные результаты операций переносятся в ОЗУ.
4. Выполнение программы завершается, в зависимости от предназначения программы, что-то может быть записано на Жёсткий диск, ОЗУ очищается(но не всегда, ведь есть new и указатели), ЦП отдыхает.

Хорошо, вроде со схемой понятно, но может возникнуть резонный вопрос, а зачем на тут разделение на ОЗУ и Жёсткий диск, почему процессор не может обходиться чем-то одним? Ну тут всё просто, ОЗУ является *быстрой*, но энергозависимой, то есть при выключении компьютера она полностью очищается. Жёсткий диск же наоборот является *медленным*, но зато не энергозависимым, то есть при выключении питания данные на нём сохранятся.  
Ещё можно вспомнить новомодные SSD и сказать что они быстре HDD. Могут ли подойти для замены RAM? Нет, пока не могут. Хоть они и в разы быстрее HDD, но также и в разы медленее RAM, поэтому пока схема `CP<=>RAM<=>HDD`, остаётся в силе.

Какое место ОЗУ занимает во время компиляции программы разобрались. Теперь немного о ней самой. ОЗУ - плата с распологающимися на ней микросхемами памяти. Внутри миксросхемы есть множество словёв, состаящих из множества ячеек. У всех этих ячеек есть свой адрес и он назывется *физическим*. По сути все вещи в программе, которые требуют ОЗУ, хранятся в физических ячейках памяти, но адреса, которые мы видим в программе, это не адреса физических ячеек памяти. Вот тут начинаются приколы. Физическая память - это фактический размер ОЗУ, но помимо физической памяти у нас есть ещё и *виртуальная*. Виртуальная память не ограничивается размерами ОЗУ и позволяет нам выходить за него. Не будем углубляться в суть работы виртуальной памяти и ёё связи с физической, потому что это довольно сложная тема и относится она больше к аппаратной части, чем к программированию, а тут всё-таки ООП, в общем просто надо усвоить, что мы работаем с адресам именно *виртуальной* памяти и то что *виртуальной* памяти больше чем реально есть физической на компе.

Память у нас линейна, то есть представляет собой непрерывную, линейную последовательность байт, естественно у каждого байта есть свой адрес. Адресация идёт в 16сс и выглядит как-то так: `00000087995BF6E4`.  

### **Способы организации памяти в C++**
---
Это те три слова: Стек, Куча и Статическая память (Stack, Heap, Static).

Сначала продробнее про каждое.

Стек - тарелки, LIFO. Хранит локальные перменные.
Куча - область памяти, которую можно использовать динамически.
Статическая память - выделяется до начала выполнения программы и хранит статические переменные.

Теперь рассуждение на тему, потому что подробный инфы я не нашёл. Память разделена на сегменты, что-то для ОС, что-то для других данных и т.д. Также есть сегмент стека и кучи, то есть области под эти модели организации.

### **Переменные и массивы в стеке**
---

Ну что же, нудное и скучное предисловие окончено, теперь начинается нудная и сложная практика.

Сначала переменные.

При создании переменной для неё выделяется адрес в области памяти, а также она там занимает место в байтах, размер зависит от типа данных переменной.

К примеру, зададим в main-e переменную `а`, из-за того что она в main-е у она будет локальной, следовательно, хранится она будет в стеке

В C++:
```c++
/*
Тут будет то что происходит в памяти

stack
===============
a[0x0000ABC0]() // В [] - адрес переменной в () её значение, тут она не инициализированна

*/

int main()
{
    int a;
}
```
Теперь инициализируем `a`.
```c++
/*

stack
===============
a[0x0000ABC0](10) // присвоили 10

*/

int main()
{
    int a = 10;
}
```
Так, тут стоит подробнее затронуть инициализацию. В том плане, как 10 хранится в `a` и как оно занимает там память? Ну что же, у `a` целочислный тип данных `int`, то есть `a` занимает в памяти 4 байта. 4 байта = 32 бита, 1 бит знак и 31 бит под число. Получается 2 в степени 31 - максимально число, которое может храниться в `int`. Когда мы объявили `a`, оно заняло в памяти 4 байта, в этих 4 байтах и хранится число 10.

Теперь обратно к муткам со стеком, зададим переменную `b`.
```c++
/*

stack
===============
b[0x0000ABF4](12) // Добавили b
a[0x0000ABC0](10) 


*/

int main()
{
    int a = 10;
    int b = 12;
}
```
Уточнение: компилятор идёт по коду сверху вниз, следовательно переменные пойдут в стек в том порядке, в котором они записаны. Ну и тут нужно заметить, что они располагаются вплотную друг к другу, в там плане, что `a` и `b` находятся примерно в одной области, но их адреса не идут последовательно друг за другом, как, к примеру в массивах, кстати о массивах, зададим массив `arr` в main-e:
```c++
/*

stack
===============
arr[0x0000ABD0](0x0000ABD0) // имя масива
arr_0[0x0000ABD0]() // Первый элемент
arr_1[0x0000ABD4]()
arr_2[0x0000ABD8]()
...
arr_9[0x0000ABF4]() // Послдений элемент массива
b[0x0000ABE4](12)
a[0x0000AB00](10) 


*/

int main()
{
    int a = 10;
    int b = 12;

    int arr[10];
}
```


<!-- ССЫЛКИ, потом надо будет добавить

Статья с DTF про устройство ОЗУ
https://dtf.ru/hard/1171475-kak-rabotaet-operativnaya-pamyat-kompyutera-ram-ozu


Про виртуальную и физическую память
https://skillbox.ru/media/code/medlenno-no-verno-kak-rabotaet-svop-razdel-podkachki-i-kak-on-ispolzuetsya-v-ipados-16/
-->