# Шаблоны (template)
---  
## Оглавление
1. [Что такое шаблоны?](#что-такое-шаблоны)  
2. [Синтаксис шаблона](#синтаксис-шаблонов)
3. [Шаблон функции](#шаблоны-функций)
4. [Шаблон класса](#шаблоны-класса)
5. [Специализация шаблона](#специализация-шаблона)
6. [Сходство и различия с классом]()
7. [Дополнительно](#дополнительно)
8. [Ссылки](#ссылки)

---

### __Что такое шаблоны?__
---

___Шаблон___ — это конструкция, которая создает обычный тип или функцию во время компиляции на основе аргументов, которые пользователь предоставляет для параметров шаблона.  

Из презентации Разумовского:  

___Шаблон___ - это класс или функция, параметризованные набором типов и/или целыми числами.  
  

Теперь простыми словами, кто это и зачем?  

Бывают моменты, когда тебе нужно, чтобы  какая-то хрень(типа класса или функции), работала с разными типами данных. Но в обычном виде функция или класс могут работать только с теми типами данных, которые заданы в параметрах, возращаемых типах данных, полях класса и т.д  

К примеру:
```C
// Функция для сравненеия двух элементов
int comparison(int n1, int n2)
{
    if (n1 > n2)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
```
Как видно, тут в параметрах у нас тип данных `int` и получается, в том случае, если нам надо будет работать, к примеру, с `double` то придётся или переписывать ту же функцию, только c изменёнными параметрами, то есть перегружать её, или вообще писать новую функцию, с тем же функционалом и изменёнными параметрами.

Вот так:
```C++
// Та же функция для сравнения, только теперь с double
int comparison(double n1, double n2)
{
    if (n1 > n2)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
```
А если нам в параметрах понадобится ещё какой-то тип, то придётся ещё раз писать такую же функцию и опять менять в ней только тип данных параметров. По факту, писать 3 раза одно и то же - неочень, поэтому придумали `template`. Он как бы задаёт "заполнитель" типа данных, то есть функция теперь не будет иметь в параметрах определённый тип данных, а будет иметь "заполнитель", в который можно будет потом передать любой тип данных.

Чтобы было понятнее, перейдём к примеру:
```C++
// Задаём шаблон
template <typename T>
// Функция сранения, только теперь в параметрах типы данных - это "T"
int comparison(T n1, T n2)
{
    if (n1 > n2)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}
```
Такой код позволит передавать в одну и ту же фукнцию аргументы разных типов данных, а не писать 10 функций под разные типы.  

Получается, что основное предназначение шаблона - это работа с конструкциями(функциями или классами), в которых могут использоваться разные типы данных.

>Шаблон - это формочка для печенья, которая указывает, как вырезать печенье, которое выглядит почти одинаково (хотя печенье может быть сделано из разных видов теста, все они будут иметь одинаковую основную форму).   
>Ну или Шаблон - это термос, а дальше и так понятно. 
 
Думаю стоит простыми словами дополнить как шаблон работает на уровне компилятора.

Когда компилятор видит **определение** шаблона, он делает заметки об этом шаблоне. Когда он видит **использование** этого шаблона, он выкапывает свои заметки, выясняет, как применить шаблон в том месте, где он используется, и генерирует код в соответствии с шаблоном, передавая на место параметра шаблона нужный тип данных.  

Ну и ещё уточнение. Шаблоны не ускоряют компиляцию, ведь компилятор генерирует новые функции или классы на их онснове, они просто сокращают количество кода.

### __Синтаксис шаблона__
---

Так, вроде с тем зачем нужны и как примерно работают шаблоны разобрались, теперь разберёмся с тем как они применяются и что нужно для них писать.

Для начала основа - задание шаблона:
```C++
template <typename T>
```

`template` - сам шаблон, это слово никак не меняется и нужно для объявления.  
`typename` - ключевое слово, которое обозначает, что шаблон является "заполнителем" для типа данных. Можно заменить на `class` и ничего не изменится, потому что они взаимозаменяемы, вроде бы есть исключения, но с 17 стандарта их убрали.  
`T` - это имя "заполнителя" типа данных, которым мы потом будем называть типы данных, можно написать что угодно, но для удобства все это называют `T`.  
То что находиться в `<>` называют параметрами типа.

Также возможно задание шаблонов с несколькими параметрами шаблонных типов.

К примеру:
```c++
template <typename T, typename U>
```
В некоторых ситуациях это может пригодиться.

Ну и напоследок. В шаблонах можно задавать аргументы по умолчанию.  

Выгдяит это так:
```c++
template <typename RT = int, typename RU = double>
```


### **Шаблоны функций**
---
Теперь, когда разобрались с синтаксисом, перейдём к основному применению шаблонов на практике. 

***Шаблонная функция*** - это обобщённое описание поведения функций, которые могут вызываться для объектов разных типов.  

Обобщенное описание так как потом на основе шаблонной функции будет создаваться новая, с переданными ей аргументами нужного типа. Чтобы лучше понять можно перечитать начало, где говорилось про работу на уровне компилятора.

На всякий случай для начала нужно уточнить: шаблоны можно задавать только **над** функциями или классами, в случайном месте кода их задать не получится. Это просто нужно запомнить и не затупить на экзамене.

Теперь для примера зададим шаблон функции:
```C++
// Сам шаблон
template <typename T>

// Функция сравнения
T my_max(T n1, T n2)
{
    return (n1 > n2)? n1: n2; // Терная операция, котора вернёт большее
}
```

Шаблон функции задали, но что будет происходить в main-е?

А там всё не так просто:
```C++
int main()
{
    std::cout << my_max<int>(3, 7) << std::endl;
    std::cout << my_max<double>(3.14, 2,1) << std::endl;
    std::cout << my_max(1,2) << std::endl; // Кто-то выдаст ошибку

    return 0; 
}
```
Тут у нас полявляется интересная конструкция:

```C++
my_max<int>(3,7)
```
В принципе, это обычный вызов функции, но с дополнением `<тип данных>`, оно является определением типа данных, которое передаётся в шаблон, в презентации Разумовского это называется *аргументом*. Так как VS хороший, в нём не обязательно писать `<тип данных>`, а можно просто:

```C++
my_max(3,7)
```

 и он сделает всё не явно, основываясь на типах аргументов функции, но некоторые компиляторы не настолько хороши и могут выдать ошибку на такое, а также у Старка это помечено как ошибка, поэтому лучше это прописывать.

### **Шаблоны Класса**
---
***Шаблонный класс*** - это пользовательский тип данных, в котором атрибуты(переменные класса) и операции(методы класса) могут быть параметризированны(то есть на место шаблона ставятся передаваемые типы).

Шаблон класса будет использоваться гораздо чаще, чем шаблон функции. И в большинстве случаев это будет шаблон для абстрактного типа, поведение которогоя является универсальным. Работает аналогично шаблону функции.

Перейдём сразу к примеру и зададим класс с шаблоном:
```c++
template <typename T>
class Account 
{
private:
    T _id;
public:
    Account(T id) : _id(id) // Конструктор для инициализации
    { }
    T getId() {
        return _id;
    }
};
```
Что в main-е:
```c++
// Указвыем тип данных, как с функцией
Account<int> acc_1(1);
```

В целом, как и говорилось выше, работает аналогично шаблону функции.

И есть важный прикол. Если класс, от которого идёт наследование шаблонный, то и все наследуемые классы должны быть шаблонными. То есть если у вас прописано `template <typename T>` только над базовым классом, а над производными нет, то у вас будет ошибка, если же вы эту конструкцию пропишите и над базовым и над производными то всё будет работать.
```c++
// Так правильно

template <typename T>
class Base
{};

template <typename T>
class Derived : public Base
{};
```

 ### __Специализация шаблона__
 ---
Иногда шаблон функции или класса может быть не эффективен или вовсе неправелен для определённых типов данных, или нам надо чтобы он вёл себя по разному с разными типами данных. В таком случае можно его ___специаллизировать___ - то есть написать его реализацию для определённого набора шаблонных аргументов  .

Специализация шаблонов немного похожа на наследование, но по своей сути больше является перегрузкой.

Пример специализации шаблона класса:
```c++
// Класс с шаблоном
template <typename T>
class Printer
{
public:

    void Print(T value)
    {
        cout << value << endl;
    }
};

// Специализация
template<>
class Printer<string> // Тут тип данных поведение которого мы хотим специализировать
{
public:
    void Print(string value)
    {
        cout << "__" << value << "__" << endl;
    }
};
```
Благодаря специализации этот класс будет вести себя по другому с объектами типа `string`. При вызове метода `Print()` объекты всех типов будут просто выводиться в консоль, а объекты типа `string` буду выводится с двумя нижними подчёркиваниями спереди и сзади.

### **Дополнительно**
---
Если что-то нужно будет дополнить, то это появится здесь.

### **Ссылки**
---
* Ролик от SimpleCode про специализацию шаблонов   
https://www.youtube.com/watch?v=_kJJoWDNvxM
* Ролик от SimpleCode про шаблоны классов  
https://www.youtube.com/watch?v=SDRMUgJwro0&t=311s
* Классная статься про шаблоны  
https://www.codeproject.com/Articles/257589/An-Idiots-Guide-to-Cplusplus-Templates-Part-1#Syntax
* Про шаблоны от Microsoft  
https://learn.microsoft.com/ru-ru/cpp/cpp/templates-cpp?view=msvc-170
* Про шаблоны с Habr  
https://habr.com/ru/post/436880/