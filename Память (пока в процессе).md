# Память
---
## Оглавление
1. А зачем это?
2. Как устроена память в C++
3. Способы организации памяти в C++
4. Переменные и массивы в стеке
5. Выравнивание
6. Ссылки
7. Указатели
8. Работа с кучей
7. Ссылки
---
### **А зачем это?**
--- 
По поводу представления памяти, стека, кучи, хранения переменных, указателей, работы ссылок и других аспектов памяти вряд ли будут задавать вопросы на экзамене(хотя могут), но понимание того как и что тут работает будет очень полезно, как и в работе, так и в изучении ООП, к примеру для работы с конструкторами копирования. Ну и к тому же Разумовский очень сильно любит пихать куда надо и не надо указатели, а Новиков ссылки, понимание их механизмов упростит работу с ними.
### **Как устроена память в C++?**
---
Ну что же, не будем брать всё устройство компа, но затронем некоторые основы. Память, которая используется при выполнении программ - оперативка. Она выступает в качетсве буфера между накопителем и процессором, то есть данные сперва считываются с жёсткого диска в ОЗУ, а потом обрабатываются ЦП. То есть схема такая:   
1. Мы пишем код, то есть набор команд  в определённом файле, далее этот файл с набором команд сохраняется на Жёстком диске.
2. Мы запускаем выполнение программы, некоторые данные с программы (типа переменных, или классов) считываются в ОЗУ. Код программы переводится в машинный и передаётся процессору.
3. Процессор начинает выполнять операции, заданные программой, все промежуточные результаты операций переносятся в ОЗУ.
4. Выполнение программы завершается, в зависимости от предназначения программы, что-то может быть записано на Жёсткий диск, ОЗУ очищается(но не всегда, ведь есть new и указатели), ЦП отдыхает.

Хорошо, вроде со схемой понятно, но может возникнуть резонный вопрос, а зачем нам тут разделение на ОЗУ и Жёсткий диск, почему процессор не может обходиться чем-то одним? Ну тут всё просто, ОЗУ является *быстрой*, но энергозависимой, то есть при выключении компьютера она полностью очищается. Жёсткий диск же наоборот является *медленным*, но зато не энергозависимым, то есть при выключении питания данные на нём сохранятся.  
Ещё можно вспомнить новомодные SSD и сказать что они быстре HDD. Могут ли они подойти для замены RAM? Нет, пока не могут. Хоть они и в разы быстрее HDD, но также и в разы медленее RAM, поэтому пока схема `CP<=>RAM<=>HDD`, остаётся в силе.

Какое место ОЗУ занимает во время компиляции программы разобрались. Теперь немного о ней самой. ОЗУ - плата с распологающимися на ней микросхемами памяти. Внутри миксросхемы есть множество словёв, состоящих из множества ячеек. У всех этих ячеек есть свой адрес и он назывется *физическим*. По сути все вещи в программе, которые требуют ОЗУ, хранятся в физических ячейках памяти, но адреса, которые мы видим в программе, это не адреса физических ячеек памяти.  

Вот тут начинаются приколы. 

Физическая память - это фактический размер ОЗУ, но помимо физической памяти у нас есть ещё и *виртуальная*. Виртуальная память не ограничивается размерами ОЗУ и позволяет нам выходить за него. Не будем углубляться в суть работы виртуальной памяти и ёё связи с физической, потому что это довольно сложная тема и относится она больше к аппаратной части, чем к программированию, а тут всё-таки ООП, в общем просто надо усвоить, что мы работаем с адресам именно *виртуальной* памяти и то что *виртуальной* памяти больше чем реально есть физической на компе.

Память у нас линейна, то есть представляет собой непрерывную, линейную последовательность байт, естественно у каждого байта есть свой адрес. Адресация идёт в 16сс и выглядит как-то так: `00000087995BF6E4`.  

### **Способы организации памяти в C++**
---
Это те три слова: Стек, Куча и Статическая память (Stack, Heap, Static). Но Стек и Куча тут важнее.

Сначала продробнее про каждое.

Стек - тарелки, LIFO. Хранит локальные перменные.  
Куча - область памяти, которую можно использовать динамически.  
Статическая память - выделяется до начала выполнения программы и хранит статические переменные.

Теперь рассуждение на тему, потому что подробной инфы я не нашёл. Память разделена на сегменты, что-то для ОС, что-то для других данных и т.д. Также есть сегмент стека и кучи, то есть области под эти модели организации.

### **Переменные и массивы в стеке**
---
*Заранее хочу сказать, что про переменные и указатели очень хорошо рассказывается в [этом ролике](https://www.youtube.com/watch?v=NCpWzpy1n0g), можно сразу посмотреть его, чтобы не тратить кучу времени на разбор написанного ниже*

Ну что же, нудное и скучное предисловие окончено, теперь начинается нудная и сложная практика.

Сначала переменные.

При создании переменной для неё выделяется адрес в области памяти, а также она там занимает место в байтах, размер зависит от типа данных переменной.

К примеру, зададим в main-e переменную `а`, из-за того что она в main-е она будет локальной, следовательно, храниться она будет в стеке.

В C++:
```c++
/*
Тут будет то что происходит в памяти

stack
===============
a[0x0000ABC0]() // [] - адрес переменной, () - её значение, тут она не инициализированна

*/

int main()
{
    int a;
}
```
Когда мы написали переменную `a` в main-e и сохранили файл, то данные с него сохраняются на жёсткий диск. При компиляции `a` поместится в стек и ей будет присвоен адрес `[0x0000ABC0]`, `()` тут пустые, потому что `a` не инициализировано, то есть оно просто забрало 4 байта в памяти, в которые ничего не положили, конечно адрес и стек тут условные, но работает всё примерно так.

Теперь инициализируем `a`.
```c++
/*

stack
===============
a[0x0000ABC0](10) // присвоили 10

*/

int main()
{
    int a = 10;
}
```
Так, тут стоит подробнее затронуть инициализацию. В том плане, как 10 хранится в `a` и как оно занимает там память? Ну что же, у `a` целочислный тип данных `int`, то есть `a` занимает в памяти 4 байта. 4 байта = 32 бита, 1 бит знак и 31 бит под число. Получается 2 в степени 31 - максимальное число, которое может храниться в `int`. Когда мы объявили `a`, оно заняло в памяти 4 байта, в этих 4 байтах и хранится число 10.

Теперь обратно к муткам со стеком, зададим переменную `b`.
```c++
/*

stack
===============
b[0x0000ABF4](12) // Добавили b
a[0x0000ABC0](10) 


*/

int main()
{
    int a = 10;
    int b = 12;
}
```
Уточнение: компилятор идёт по коду сверху вниз, следовательно переменные пойдут в стек в том порядке, в котором они записаны. Ну и тут нужно заметить, что они не располагаются вплотную друг к другу, в том плане, что `a` и `b` находятся примерно в одной области, но их адреса не идут последовательно друг за другом, как, к примеру в массивах, кстати о массивах, зададим массив `arr` в main-e:
```c++
/*

stack
===============
arr[0x0000ABD0](0x0000ABD0) // имя масива
arr_0[0x0000ABD0]() // Первый элемент
arr_1[0x0000ABD4]()
arr_2[0x0000ABD8]()
...
arr_9[0x0000ABF4]() // Послдений элемент массива
b[0x0000ABE4](12)
a[0x0000AB00](10) 


*/

int main()
{
    int a = 10;
    int b = 12;

    int arr[10];
}
```
Как видно, элементы массива располагаются в памяти прямо друг за другом. Название массива это указатель на 1-ый элемент массива, но не совсем обычный так как он имеет то же адрес, что хранится в нём, ну и этот указатеь является константным, то есть хранимый в нём адрес изменить нельзя. Тема с указателями будет дальше.
### **Выравнивание памяти**
---
Немного отвлечёмся от кода.

У переменных есть интресная фишка с памятью, которая связана с типом данных.  
Компилятор распологает базовые типы в памяти так, чтобы обеспечить к ним наиболее быстрый доступ. Каждый тип, кроме `char` требует *выравнивания*.   
К примеру сам `char` может начинаться с любого адреса, 4-х байтовый `int` или `float` - с адреса, кратного 4-м, 8-ми байтовый `double` или `long` с адреса кратного 8-ми. Указатели также выравниваются.

Выравнивание ускоряет доступ к памяти за счёт генрации кода, в котором на чтение и запись ячейки памяти трбуется по 1-ой инструкции.
### **Ссылки**
---
Тепере обратно к коду и стеку.

Если вспомнить первый семестр то ***ссылка*** - это альтернатьвное имя для объекта. С точки зрения памяти это тоже выглядит не сложно.  

Сразу к примеру:
```c++

/*

stack
===============
r_a[0x0000ABF0](10)
a[0x0000ABF0](10)

*/

int main()
{
    int a = 10;
    int& r_a = a; // Создали ссылку на а
}

```
На уровне языка ссылка реализуется, как просто другое имя для объекта и не должна занимать место в памяти. Но на аппаратном уровне всё немного по другому. Хоть в стеке и видно, что `r_a` полностью индентична `a`, но компилятор будет её реализовывать как указатель, а у указателей свой адрес в памяти.
### **Указатели**
---
Они уже 2 раза затрагивались в тексте, пора уже и разобраться как они работают. Опять же вернёмся в первый семестр и вспомним что такое указатель.  

***Указатель*** - переменная, которая хранит в себе адрес другой переменной.   

Конечно в презентации Ряшенцева это был тип данных, и отчасти это даже верно, но всё - таки называть указатель переменной как-то проще и логичнее.

Теперь посмотрим, что происходит в памяти, когда у нас в программе появляется указатель.
```c++

/*

stack
===============
ptr_a[0x0000AD44](0x0000ABF0) // Указатель появился в стеке
a[0x0000ABF0](10)

*/

int main()
{
    int a = 10;
    
    int* ptr_a = &a; // Создаём указатель на переменную а. & - операция взятия адреса
}

```
Как тут видно, у указателя свой адрес в памяти `[0x0000AD44]`, а его значение это адрес переменной `a`, то есть `(0x0000ABF0)`, всё также как и в определении, хранит в себе адрес переменной.

Теперь возьмём вещь поинтереснее. Указатель на указатель.
```c++

/*

stack
===============
ptr_ptr_a[0x0000AF08](0x0000AD44) // А вот и указатель на указатель в стеке
ptr_a[0x0000AD44](0x0000ABF0) 
a[0x0000ABF0](10)

*/

int main()
{
    int a = 10;
    
    int* ptr_a = &a;
    int** ptr_ptr_a = &ptr_a; // Уазатель на указатель
}

```
В общем прицнци понятен, по новому адресу `[0x0000AF08]` был создан указатель `ptr_ptr_a`, а этот указатель был записан адрес другого указатель, то есть `(0x0000AD44)`. С двойными, тройными, пятерными и т.д. указтелями принцип тот же.
```c++

/*

stack
===============
ptr_ptr_ptr_ptr_a[0x0000AFBC](0x0000AB04)
ptr_ptr_ptr_a[0x0000AB04](0x0000AF08)
ptr_ptr_a[0x0000AF08](0x0000AD44)
ptr_a[0x0000AD44](0x0000ABF0) 
a[0x0000ABF0](10)

*/

int main()
{
    int a = 10;
    
    int* ptr_a = &a;
    int** ptr_ptr_a = &ptr_a;
    int*** ptr_ptr_ptr_a = &ptr_ptr_a;
    int**** ptr_ptr_ptr_ptr_a = &ptr_ptr_ptr_a;
    // и т. д.
}

```
### **Работа с кучей**
---
Ну чтоже, после указателей нужно разобрать тему в которой они больше всего применяются.

Для начала, памяти в куче выделяется при помощи операции `new`, освобождается соответсвенно при помощи `delete`. В куче мы можем создавать только массивы, всё что не массив уходит либо в стек, либо в статитечкую память.

Теперь к делу:
```c++

/*

stack
===============
h_a[0x0000BBF0](0x0000DF98)


heap
===============
h_a[0x0000DF98](0x000082B0)
h_0[0x000082B0]()
h_1[0x000082B4]()
....
h_9[0x000082D4]()

*/

int main()
{
    int* h_a = new int[10]; // Задали динамический массив
}
```

<!-- ССЫЛКИ, потом надо будет добавить

Статья с DTF про устройство ОЗУ
https://dtf.ru/hard/1171475-kak-rabotaet-operativnaya-pamyat-kompyutera-ram-ozu


Про виртуальную и физическую память
https://skillbox.ru/media/code/medlenno-no-verno-kak-rabotaet-svop-razdel-podkachki-i-kak-on-ispolzuetsya-v-ipados-16/
-->